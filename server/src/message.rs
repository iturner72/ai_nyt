// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc 3.12.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `message.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:Message)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Message {
    // message fields
    // @@protoc_insertion_point(field:Message.data)
    pub data: ::protobuf::MessageField<MessageData>,
    // @@protoc_insertion_point(field:Message.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:Message.hash_scheme)
    pub hash_scheme: ::protobuf::EnumOrUnknown<HashScheme>,
    // @@protoc_insertion_point(field:Message.signature)
    pub signature: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:Message.signature_scheme)
    pub signature_scheme: ::protobuf::EnumOrUnknown<SignatureScheme>,
    // @@protoc_insertion_point(field:Message.signer)
    pub signer: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:Message.data_bytes)
    pub data_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MessageData>(
            "data",
            |m: &Message| { &m.data },
            |m: &mut Message| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &Message| { &m.hash },
            |m: &mut Message| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash_scheme",
            |m: &Message| { &m.hash_scheme },
            |m: &mut Message| { &mut m.hash_scheme },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &Message| { &m.signature },
            |m: &mut Message| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature_scheme",
            |m: &Message| { &m.signature_scheme },
            |m: &mut Message| { &mut m.signature_scheme },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signer",
            |m: &Message| { &m.signer },
            |m: &mut Message| { &mut m.signer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_bytes",
            |m: &Message| { &m.data_bytes },
            |m: &mut Message| { &mut m.data_bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
            "Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Message {
    const NAME: &'static str = "Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                18 => {
                    self.hash = is.read_bytes()?;
                },
                24 => {
                    self.hash_scheme = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.signature = is.read_bytes()?;
                },
                40 => {
                    self.signature_scheme = is.read_enum_or_unknown()?;
                },
                50 => {
                    self.signer = is.read_bytes()?;
                },
                58 => {
                    self.data_bytes = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        if self.hash_scheme != ::protobuf::EnumOrUnknown::new(HashScheme::HASH_SCHEME_NONE) {
            my_size += ::protobuf::rt::int32_size(3, self.hash_scheme.value());
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.signature);
        }
        if self.signature_scheme != ::protobuf::EnumOrUnknown::new(SignatureScheme::SIGNATURE_SCHEME_NONE) {
            my_size += ::protobuf::rt::int32_size(5, self.signature_scheme.value());
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.signer);
        }
        if let Some(v) = self.data_bytes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        if self.hash_scheme != ::protobuf::EnumOrUnknown::new(HashScheme::HASH_SCHEME_NONE) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.hash_scheme))?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(4, &self.signature)?;
        }
        if self.signature_scheme != ::protobuf::EnumOrUnknown::new(SignatureScheme::SIGNATURE_SCHEME_NONE) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.signature_scheme))?;
        }
        if !self.signer.is_empty() {
            os.write_bytes(6, &self.signer)?;
        }
        if let Some(v) = self.data_bytes.as_ref() {
            os.write_bytes(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Message {
        Message::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.hash.clear();
        self.hash_scheme = ::protobuf::EnumOrUnknown::new(HashScheme::HASH_SCHEME_NONE);
        self.signature.clear();
        self.signature_scheme = ::protobuf::EnumOrUnknown::new(SignatureScheme::SIGNATURE_SCHEME_NONE);
        self.signer.clear();
        self.data_bytes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Message {
        static instance: Message = Message {
            data: ::protobuf::MessageField::none(),
            hash: ::std::vec::Vec::new(),
            hash_scheme: ::protobuf::EnumOrUnknown::from_i32(0),
            signature: ::std::vec::Vec::new(),
            signature_scheme: ::protobuf::EnumOrUnknown::from_i32(0),
            signer: ::std::vec::Vec::new(),
            data_bytes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MessageData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageData {
    // message fields
    // @@protoc_insertion_point(field:MessageData.type)
    pub type_: ::protobuf::EnumOrUnknown<MessageType>,
    // @@protoc_insertion_point(field:MessageData.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:MessageData.timestamp)
    pub timestamp: u32,
    // @@protoc_insertion_point(field:MessageData.network)
    pub network: ::protobuf::EnumOrUnknown<FarcasterNetwork>,
    // message oneof groups
    pub body: ::std::option::Option<message_data::Body>,
    // special fields
    // @@protoc_insertion_point(special_field:MessageData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageData {
    fn default() -> &'a MessageData {
        <MessageData as ::protobuf::Message>::default_instance()
    }
}

impl MessageData {
    pub fn new() -> MessageData {
        ::std::default::Default::default()
    }

    // .CastAddBody cast_add_body = 5;

    pub fn cast_add_body(&self) -> &CastAddBody {
        match self.body {
            ::std::option::Option::Some(message_data::Body::CastAddBody(ref v)) => v,
            _ => <CastAddBody as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cast_add_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_cast_add_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(message_data::Body::CastAddBody(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cast_add_body(&mut self, v: CastAddBody) {
        self.body = ::std::option::Option::Some(message_data::Body::CastAddBody(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cast_add_body(&mut self) -> &mut CastAddBody {
        if let ::std::option::Option::Some(message_data::Body::CastAddBody(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(message_data::Body::CastAddBody(CastAddBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(message_data::Body::CastAddBody(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cast_add_body(&mut self) -> CastAddBody {
        if self.has_cast_add_body() {
            match self.body.take() {
                ::std::option::Option::Some(message_data::Body::CastAddBody(v)) => v,
                _ => panic!(),
            }
        } else {
            CastAddBody::new()
        }
    }

    // .CastRemoveBody cast_remove_body = 6;

    pub fn cast_remove_body(&self) -> &CastRemoveBody {
        match self.body {
            ::std::option::Option::Some(message_data::Body::CastRemoveBody(ref v)) => v,
            _ => <CastRemoveBody as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cast_remove_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_cast_remove_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(message_data::Body::CastRemoveBody(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cast_remove_body(&mut self, v: CastRemoveBody) {
        self.body = ::std::option::Option::Some(message_data::Body::CastRemoveBody(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cast_remove_body(&mut self) -> &mut CastRemoveBody {
        if let ::std::option::Option::Some(message_data::Body::CastRemoveBody(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(message_data::Body::CastRemoveBody(CastRemoveBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(message_data::Body::CastRemoveBody(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cast_remove_body(&mut self) -> CastRemoveBody {
        if self.has_cast_remove_body() {
            match self.body.take() {
                ::std::option::Option::Some(message_data::Body::CastRemoveBody(v)) => v,
                _ => panic!(),
            }
        } else {
            CastRemoveBody::new()
        }
    }

    // .ReactionBody reaction_body = 7;

    pub fn reaction_body(&self) -> &ReactionBody {
        match self.body {
            ::std::option::Option::Some(message_data::Body::ReactionBody(ref v)) => v,
            _ => <ReactionBody as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_reaction_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_reaction_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(message_data::Body::ReactionBody(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reaction_body(&mut self, v: ReactionBody) {
        self.body = ::std::option::Option::Some(message_data::Body::ReactionBody(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reaction_body(&mut self) -> &mut ReactionBody {
        if let ::std::option::Option::Some(message_data::Body::ReactionBody(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(message_data::Body::ReactionBody(ReactionBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(message_data::Body::ReactionBody(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reaction_body(&mut self) -> ReactionBody {
        if self.has_reaction_body() {
            match self.body.take() {
                ::std::option::Option::Some(message_data::Body::ReactionBody(v)) => v,
                _ => panic!(),
            }
        } else {
            ReactionBody::new()
        }
    }

    // .VerificationAddAddressBody verification_add_address_body = 9;

    pub fn verification_add_address_body(&self) -> &VerificationAddAddressBody {
        match self.body {
            ::std::option::Option::Some(message_data::Body::VerificationAddAddressBody(ref v)) => v,
            _ => <VerificationAddAddressBody as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_verification_add_address_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_verification_add_address_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(message_data::Body::VerificationAddAddressBody(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_verification_add_address_body(&mut self, v: VerificationAddAddressBody) {
        self.body = ::std::option::Option::Some(message_data::Body::VerificationAddAddressBody(v))
    }

    // Mutable pointer to the field.
    pub fn mut_verification_add_address_body(&mut self) -> &mut VerificationAddAddressBody {
        if let ::std::option::Option::Some(message_data::Body::VerificationAddAddressBody(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(message_data::Body::VerificationAddAddressBody(VerificationAddAddressBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(message_data::Body::VerificationAddAddressBody(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_verification_add_address_body(&mut self) -> VerificationAddAddressBody {
        if self.has_verification_add_address_body() {
            match self.body.take() {
                ::std::option::Option::Some(message_data::Body::VerificationAddAddressBody(v)) => v,
                _ => panic!(),
            }
        } else {
            VerificationAddAddressBody::new()
        }
    }

    // .VerificationRemoveBody verification_remove_body = 10;

    pub fn verification_remove_body(&self) -> &VerificationRemoveBody {
        match self.body {
            ::std::option::Option::Some(message_data::Body::VerificationRemoveBody(ref v)) => v,
            _ => <VerificationRemoveBody as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_verification_remove_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_verification_remove_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(message_data::Body::VerificationRemoveBody(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_verification_remove_body(&mut self, v: VerificationRemoveBody) {
        self.body = ::std::option::Option::Some(message_data::Body::VerificationRemoveBody(v))
    }

    // Mutable pointer to the field.
    pub fn mut_verification_remove_body(&mut self) -> &mut VerificationRemoveBody {
        if let ::std::option::Option::Some(message_data::Body::VerificationRemoveBody(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(message_data::Body::VerificationRemoveBody(VerificationRemoveBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(message_data::Body::VerificationRemoveBody(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_verification_remove_body(&mut self) -> VerificationRemoveBody {
        if self.has_verification_remove_body() {
            match self.body.take() {
                ::std::option::Option::Some(message_data::Body::VerificationRemoveBody(v)) => v,
                _ => panic!(),
            }
        } else {
            VerificationRemoveBody::new()
        }
    }

    // .UserDataBody user_data_body = 12;

    pub fn user_data_body(&self) -> &UserDataBody {
        match self.body {
            ::std::option::Option::Some(message_data::Body::UserDataBody(ref v)) => v,
            _ => <UserDataBody as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_user_data_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_user_data_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(message_data::Body::UserDataBody(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_data_body(&mut self, v: UserDataBody) {
        self.body = ::std::option::Option::Some(message_data::Body::UserDataBody(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_data_body(&mut self) -> &mut UserDataBody {
        if let ::std::option::Option::Some(message_data::Body::UserDataBody(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(message_data::Body::UserDataBody(UserDataBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(message_data::Body::UserDataBody(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_data_body(&mut self) -> UserDataBody {
        if self.has_user_data_body() {
            match self.body.take() {
                ::std::option::Option::Some(message_data::Body::UserDataBody(v)) => v,
                _ => panic!(),
            }
        } else {
            UserDataBody::new()
        }
    }

    // .LinkBody link_body = 14;

    pub fn link_body(&self) -> &LinkBody {
        match self.body {
            ::std::option::Option::Some(message_data::Body::LinkBody(ref v)) => v,
            _ => <LinkBody as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_link_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_link_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(message_data::Body::LinkBody(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_link_body(&mut self, v: LinkBody) {
        self.body = ::std::option::Option::Some(message_data::Body::LinkBody(v))
    }

    // Mutable pointer to the field.
    pub fn mut_link_body(&mut self) -> &mut LinkBody {
        if let ::std::option::Option::Some(message_data::Body::LinkBody(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(message_data::Body::LinkBody(LinkBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(message_data::Body::LinkBody(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_link_body(&mut self) -> LinkBody {
        if self.has_link_body() {
            match self.body.take() {
                ::std::option::Option::Some(message_data::Body::LinkBody(v)) => v,
                _ => panic!(),
            }
        } else {
            LinkBody::new()
        }
    }

    // .UserNameProof username_proof_body = 15;

    pub fn username_proof_body(&self) -> &super::username_proof::UserNameProof {
        match self.body {
            ::std::option::Option::Some(message_data::Body::UsernameProofBody(ref v)) => v,
            _ => <super::username_proof::UserNameProof as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_username_proof_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_username_proof_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(message_data::Body::UsernameProofBody(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_username_proof_body(&mut self, v: super::username_proof::UserNameProof) {
        self.body = ::std::option::Option::Some(message_data::Body::UsernameProofBody(v))
    }

    // Mutable pointer to the field.
    pub fn mut_username_proof_body(&mut self) -> &mut super::username_proof::UserNameProof {
        if let ::std::option::Option::Some(message_data::Body::UsernameProofBody(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(message_data::Body::UsernameProofBody(super::username_proof::UserNameProof::new()));
        }
        match self.body {
            ::std::option::Option::Some(message_data::Body::UsernameProofBody(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_username_proof_body(&mut self) -> super::username_proof::UserNameProof {
        if self.has_username_proof_body() {
            match self.body.take() {
                ::std::option::Option::Some(message_data::Body::UsernameProofBody(v)) => v,
                _ => panic!(),
            }
        } else {
            super::username_proof::UserNameProof::new()
        }
    }

    // .FrameActionBody frame_action_body = 16;

    pub fn frame_action_body(&self) -> &FrameActionBody {
        match self.body {
            ::std::option::Option::Some(message_data::Body::FrameActionBody(ref v)) => v,
            _ => <FrameActionBody as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_frame_action_body(&mut self) {
        self.body = ::std::option::Option::None;
    }

    pub fn has_frame_action_body(&self) -> bool {
        match self.body {
            ::std::option::Option::Some(message_data::Body::FrameActionBody(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_frame_action_body(&mut self, v: FrameActionBody) {
        self.body = ::std::option::Option::Some(message_data::Body::FrameActionBody(v))
    }

    // Mutable pointer to the field.
    pub fn mut_frame_action_body(&mut self) -> &mut FrameActionBody {
        if let ::std::option::Option::Some(message_data::Body::FrameActionBody(_)) = self.body {
        } else {
            self.body = ::std::option::Option::Some(message_data::Body::FrameActionBody(FrameActionBody::new()));
        }
        match self.body {
            ::std::option::Option::Some(message_data::Body::FrameActionBody(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_frame_action_body(&mut self) -> FrameActionBody {
        if self.has_frame_action_body() {
            match self.body.take() {
                ::std::option::Option::Some(message_data::Body::FrameActionBody(v)) => v,
                _ => panic!(),
            }
        } else {
            FrameActionBody::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &MessageData| { &m.type_ },
            |m: &mut MessageData| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &MessageData| { &m.fid },
            |m: &mut MessageData| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestamp",
            |m: &MessageData| { &m.timestamp },
            |m: &mut MessageData| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "network",
            |m: &MessageData| { &m.network },
            |m: &mut MessageData| { &mut m.network },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CastAddBody>(
            "cast_add_body",
            MessageData::has_cast_add_body,
            MessageData::cast_add_body,
            MessageData::mut_cast_add_body,
            MessageData::set_cast_add_body,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CastRemoveBody>(
            "cast_remove_body",
            MessageData::has_cast_remove_body,
            MessageData::cast_remove_body,
            MessageData::mut_cast_remove_body,
            MessageData::set_cast_remove_body,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ReactionBody>(
            "reaction_body",
            MessageData::has_reaction_body,
            MessageData::reaction_body,
            MessageData::mut_reaction_body,
            MessageData::set_reaction_body,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VerificationAddAddressBody>(
            "verification_add_address_body",
            MessageData::has_verification_add_address_body,
            MessageData::verification_add_address_body,
            MessageData::mut_verification_add_address_body,
            MessageData::set_verification_add_address_body,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, VerificationRemoveBody>(
            "verification_remove_body",
            MessageData::has_verification_remove_body,
            MessageData::verification_remove_body,
            MessageData::mut_verification_remove_body,
            MessageData::set_verification_remove_body,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UserDataBody>(
            "user_data_body",
            MessageData::has_user_data_body,
            MessageData::user_data_body,
            MessageData::mut_user_data_body,
            MessageData::set_user_data_body,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, LinkBody>(
            "link_body",
            MessageData::has_link_body,
            MessageData::link_body,
            MessageData::mut_link_body,
            MessageData::set_link_body,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, super::username_proof::UserNameProof>(
            "username_proof_body",
            MessageData::has_username_proof_body,
            MessageData::username_proof_body,
            MessageData::mut_username_proof_body,
            MessageData::set_username_proof_body,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, FrameActionBody>(
            "frame_action_body",
            MessageData::has_frame_action_body,
            MessageData::frame_action_body,
            MessageData::mut_frame_action_body,
            MessageData::set_frame_action_body,
        ));
        oneofs.push(message_data::Body::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessageData>(
            "MessageData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MessageData {
    const NAME: &'static str = "MessageData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.fid = is.read_uint64()?;
                },
                24 => {
                    self.timestamp = is.read_uint32()?;
                },
                32 => {
                    self.network = is.read_enum_or_unknown()?;
                },
                42 => {
                    self.body = ::std::option::Option::Some(message_data::Body::CastAddBody(is.read_message()?));
                },
                50 => {
                    self.body = ::std::option::Option::Some(message_data::Body::CastRemoveBody(is.read_message()?));
                },
                58 => {
                    self.body = ::std::option::Option::Some(message_data::Body::ReactionBody(is.read_message()?));
                },
                74 => {
                    self.body = ::std::option::Option::Some(message_data::Body::VerificationAddAddressBody(is.read_message()?));
                },
                82 => {
                    self.body = ::std::option::Option::Some(message_data::Body::VerificationRemoveBody(is.read_message()?));
                },
                98 => {
                    self.body = ::std::option::Option::Some(message_data::Body::UserDataBody(is.read_message()?));
                },
                114 => {
                    self.body = ::std::option::Option::Some(message_data::Body::LinkBody(is.read_message()?));
                },
                122 => {
                    self.body = ::std::option::Option::Some(message_data::Body::UsernameProofBody(is.read_message()?));
                },
                130 => {
                    self.body = ::std::option::Option::Some(message_data::Body::FrameActionBody(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(MessageType::MESSAGE_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.fid);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.timestamp);
        }
        if self.network != ::protobuf::EnumOrUnknown::new(FarcasterNetwork::FARCASTER_NETWORK_NONE) {
            my_size += ::protobuf::rt::int32_size(4, self.network.value());
        }
        if let ::std::option::Option::Some(ref v) = self.body {
            match v {
                &message_data::Body::CastAddBody(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_data::Body::CastRemoveBody(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_data::Body::ReactionBody(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_data::Body::VerificationAddAddressBody(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_data::Body::VerificationRemoveBody(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_data::Body::UserDataBody(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_data::Body::LinkBody(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_data::Body::UsernameProofBody(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &message_data::Body::FrameActionBody(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(MessageType::MESSAGE_TYPE_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if self.fid != 0 {
            os.write_uint64(2, self.fid)?;
        }
        if self.timestamp != 0 {
            os.write_uint32(3, self.timestamp)?;
        }
        if self.network != ::protobuf::EnumOrUnknown::new(FarcasterNetwork::FARCASTER_NETWORK_NONE) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.network))?;
        }
        if let ::std::option::Option::Some(ref v) = self.body {
            match v {
                &message_data::Body::CastAddBody(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &message_data::Body::CastRemoveBody(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &message_data::Body::ReactionBody(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &message_data::Body::VerificationAddAddressBody(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &message_data::Body::VerificationRemoveBody(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &message_data::Body::UserDataBody(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &message_data::Body::LinkBody(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
                },
                &message_data::Body::UsernameProofBody(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
                },
                &message_data::Body::FrameActionBody(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageData {
        MessageData::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(MessageType::MESSAGE_TYPE_NONE);
        self.fid = 0;
        self.timestamp = 0;
        self.network = ::protobuf::EnumOrUnknown::new(FarcasterNetwork::FARCASTER_NETWORK_NONE);
        self.body = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.body = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageData {
        static instance: MessageData = MessageData {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            fid: 0,
            timestamp: 0,
            network: ::protobuf::EnumOrUnknown::from_i32(0),
            body: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MessageData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MessageData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MessageData`
pub mod message_data {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:MessageData.body)
    pub enum Body {
        // @@protoc_insertion_point(oneof_field:MessageData.cast_add_body)
        CastAddBody(super::CastAddBody),
        // @@protoc_insertion_point(oneof_field:MessageData.cast_remove_body)
        CastRemoveBody(super::CastRemoveBody),
        // @@protoc_insertion_point(oneof_field:MessageData.reaction_body)
        ReactionBody(super::ReactionBody),
        // @@protoc_insertion_point(oneof_field:MessageData.verification_add_address_body)
        VerificationAddAddressBody(super::VerificationAddAddressBody),
        // @@protoc_insertion_point(oneof_field:MessageData.verification_remove_body)
        VerificationRemoveBody(super::VerificationRemoveBody),
        // @@protoc_insertion_point(oneof_field:MessageData.user_data_body)
        UserDataBody(super::UserDataBody),
        // @@protoc_insertion_point(oneof_field:MessageData.link_body)
        LinkBody(super::LinkBody),
        // @@protoc_insertion_point(oneof_field:MessageData.username_proof_body)
        UsernameProofBody(super::super::username_proof::UserNameProof),
        // @@protoc_insertion_point(oneof_field:MessageData.frame_action_body)
        FrameActionBody(super::FrameActionBody),
    }

    impl ::protobuf::Oneof for Body {
    }

    impl ::protobuf::OneofFull for Body {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::MessageData as ::protobuf::MessageFull>::descriptor().oneof_by_name("body").unwrap()).clone()
        }
    }

    impl Body {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Body>("body")
        }
    }
}

// @@protoc_insertion_point(message:UserDataBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserDataBody {
    // message fields
    // @@protoc_insertion_point(field:UserDataBody.type)
    pub type_: ::protobuf::EnumOrUnknown<UserDataType>,
    // @@protoc_insertion_point(field:UserDataBody.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:UserDataBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserDataBody {
    fn default() -> &'a UserDataBody {
        <UserDataBody as ::protobuf::Message>::default_instance()
    }
}

impl UserDataBody {
    pub fn new() -> UserDataBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &UserDataBody| { &m.type_ },
            |m: &mut UserDataBody| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &UserDataBody| { &m.value },
            |m: &mut UserDataBody| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserDataBody>(
            "UserDataBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserDataBody {
    const NAME: &'static str = "UserDataBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(UserDataType::USER_DATA_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(UserDataType::USER_DATA_TYPE_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserDataBody {
        UserDataBody::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(UserDataType::USER_DATA_TYPE_NONE);
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserDataBody {
        static instance: UserDataBody = UserDataBody {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserDataBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserDataBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserDataBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserDataBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:Embed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Embed {
    // message oneof groups
    pub embed: ::std::option::Option<embed::Embed>,
    // special fields
    // @@protoc_insertion_point(special_field:Embed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Embed {
    fn default() -> &'a Embed {
        <Embed as ::protobuf::Message>::default_instance()
    }
}

impl Embed {
    pub fn new() -> Embed {
        ::std::default::Default::default()
    }

    // string url = 1;

    pub fn url(&self) -> &str {
        match self.embed {
            ::std::option::Option::Some(embed::Embed::Url(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.embed = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        match self.embed {
            ::std::option::Option::Some(embed::Embed::Url(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.embed = ::std::option::Option::Some(embed::Embed::Url(v))
    }

    // Mutable pointer to the field.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(embed::Embed::Url(_)) = self.embed {
        } else {
            self.embed = ::std::option::Option::Some(embed::Embed::Url(::std::string::String::new()));
        }
        match self.embed {
            ::std::option::Option::Some(embed::Embed::Url(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        if self.has_url() {
            match self.embed.take() {
                ::std::option::Option::Some(embed::Embed::Url(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .CastId cast_id = 2;

    pub fn cast_id(&self) -> &CastId {
        match self.embed {
            ::std::option::Option::Some(embed::Embed::CastId(ref v)) => v,
            _ => <CastId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_cast_id(&mut self) {
        self.embed = ::std::option::Option::None;
    }

    pub fn has_cast_id(&self) -> bool {
        match self.embed {
            ::std::option::Option::Some(embed::Embed::CastId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cast_id(&mut self, v: CastId) {
        self.embed = ::std::option::Option::Some(embed::Embed::CastId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cast_id(&mut self) -> &mut CastId {
        if let ::std::option::Option::Some(embed::Embed::CastId(_)) = self.embed {
        } else {
            self.embed = ::std::option::Option::Some(embed::Embed::CastId(CastId::new()));
        }
        match self.embed {
            ::std::option::Option::Some(embed::Embed::CastId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cast_id(&mut self) -> CastId {
        if self.has_cast_id() {
            match self.embed.take() {
                ::std::option::Option::Some(embed::Embed::CastId(v)) => v,
                _ => panic!(),
            }
        } else {
            CastId::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "url",
            Embed::has_url,
            Embed::url,
            Embed::set_url,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CastId>(
            "cast_id",
            Embed::has_cast_id,
            Embed::cast_id,
            Embed::mut_cast_id,
            Embed::set_cast_id,
        ));
        oneofs.push(embed::Embed::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Embed>(
            "Embed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Embed {
    const NAME: &'static str = "Embed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.embed = ::std::option::Option::Some(embed::Embed::Url(is.read_string()?));
                },
                18 => {
                    self.embed = ::std::option::Option::Some(embed::Embed::CastId(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.embed {
            match v {
                &embed::Embed::Url(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &embed::Embed::CastId(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.embed {
            match v {
                &embed::Embed::Url(ref v) => {
                    os.write_string(1, v)?;
                },
                &embed::Embed::CastId(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Embed {
        Embed::new()
    }

    fn clear(&mut self) {
        self.embed = ::std::option::Option::None;
        self.embed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Embed {
        static instance: Embed = Embed {
            embed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Embed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Embed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Embed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Embed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Embed`
pub mod embed {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:Embed.embed)
    pub enum Embed {
        // @@protoc_insertion_point(oneof_field:Embed.url)
        Url(::std::string::String),
        // @@protoc_insertion_point(oneof_field:Embed.cast_id)
        CastId(super::CastId),
    }

    impl ::protobuf::Oneof for Embed {
    }

    impl ::protobuf::OneofFull for Embed {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Embed as ::protobuf::MessageFull>::descriptor().oneof_by_name("embed").unwrap()).clone()
        }
    }

    impl Embed {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Embed>("embed")
        }
    }
}

// @@protoc_insertion_point(message:CastAddBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CastAddBody {
    // message fields
    // @@protoc_insertion_point(field:CastAddBody.embeds_deprecated)
    pub embeds_deprecated: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CastAddBody.mentions)
    pub mentions: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CastAddBody.text)
    pub text: ::std::string::String,
    // @@protoc_insertion_point(field:CastAddBody.mentions_positions)
    pub mentions_positions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CastAddBody.embeds)
    pub embeds: ::std::vec::Vec<Embed>,
    // message oneof groups
    pub parent: ::std::option::Option<cast_add_body::Parent>,
    // special fields
    // @@protoc_insertion_point(special_field:CastAddBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CastAddBody {
    fn default() -> &'a CastAddBody {
        <CastAddBody as ::protobuf::Message>::default_instance()
    }
}

impl CastAddBody {
    pub fn new() -> CastAddBody {
        ::std::default::Default::default()
    }

    // .CastId parent_cast_id = 3;

    pub fn parent_cast_id(&self) -> &CastId {
        match self.parent {
            ::std::option::Option::Some(cast_add_body::Parent::ParentCastId(ref v)) => v,
            _ => <CastId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_parent_cast_id(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent_cast_id(&self) -> bool {
        match self.parent {
            ::std::option::Option::Some(cast_add_body::Parent::ParentCastId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_parent_cast_id(&mut self, v: CastId) {
        self.parent = ::std::option::Option::Some(cast_add_body::Parent::ParentCastId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_parent_cast_id(&mut self) -> &mut CastId {
        if let ::std::option::Option::Some(cast_add_body::Parent::ParentCastId(_)) = self.parent {
        } else {
            self.parent = ::std::option::Option::Some(cast_add_body::Parent::ParentCastId(CastId::new()));
        }
        match self.parent {
            ::std::option::Option::Some(cast_add_body::Parent::ParentCastId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_parent_cast_id(&mut self) -> CastId {
        if self.has_parent_cast_id() {
            match self.parent.take() {
                ::std::option::Option::Some(cast_add_body::Parent::ParentCastId(v)) => v,
                _ => panic!(),
            }
        } else {
            CastId::new()
        }
    }

    // string parent_url = 7;

    pub fn parent_url(&self) -> &str {
        match self.parent {
            ::std::option::Option::Some(cast_add_body::Parent::ParentUrl(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_parent_url(&mut self) {
        self.parent = ::std::option::Option::None;
    }

    pub fn has_parent_url(&self) -> bool {
        match self.parent {
            ::std::option::Option::Some(cast_add_body::Parent::ParentUrl(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_parent_url(&mut self, v: ::std::string::String) {
        self.parent = ::std::option::Option::Some(cast_add_body::Parent::ParentUrl(v))
    }

    // Mutable pointer to the field.
    pub fn mut_parent_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(cast_add_body::Parent::ParentUrl(_)) = self.parent {
        } else {
            self.parent = ::std::option::Option::Some(cast_add_body::Parent::ParentUrl(::std::string::String::new()));
        }
        match self.parent {
            ::std::option::Option::Some(cast_add_body::Parent::ParentUrl(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_parent_url(&mut self) -> ::std::string::String {
        if self.has_parent_url() {
            match self.parent.take() {
                ::std::option::Option::Some(cast_add_body::Parent::ParentUrl(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "embeds_deprecated",
            |m: &CastAddBody| { &m.embeds_deprecated },
            |m: &mut CastAddBody| { &mut m.embeds_deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mentions",
            |m: &CastAddBody| { &m.mentions },
            |m: &mut CastAddBody| { &mut m.mentions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CastId>(
            "parent_cast_id",
            CastAddBody::has_parent_cast_id,
            CastAddBody::parent_cast_id,
            CastAddBody::mut_parent_cast_id,
            CastAddBody::set_parent_cast_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "parent_url",
            CastAddBody::has_parent_url,
            CastAddBody::parent_url,
            CastAddBody::set_parent_url,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &CastAddBody| { &m.text },
            |m: &mut CastAddBody| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mentions_positions",
            |m: &CastAddBody| { &m.mentions_positions },
            |m: &mut CastAddBody| { &mut m.mentions_positions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "embeds",
            |m: &CastAddBody| { &m.embeds },
            |m: &mut CastAddBody| { &mut m.embeds },
        ));
        oneofs.push(cast_add_body::Parent::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CastAddBody>(
            "CastAddBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CastAddBody {
    const NAME: &'static str = "CastAddBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.embeds_deprecated.push(is.read_string()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.mentions)?;
                },
                16 => {
                    self.mentions.push(is.read_uint64()?);
                },
                26 => {
                    self.parent = ::std::option::Option::Some(cast_add_body::Parent::ParentCastId(is.read_message()?));
                },
                58 => {
                    self.parent = ::std::option::Option::Some(cast_add_body::Parent::ParentUrl(is.read_string()?));
                },
                34 => {
                    self.text = is.read_string()?;
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.mentions_positions)?;
                },
                40 => {
                    self.mentions_positions.push(is.read_uint32()?);
                },
                50 => {
                    self.embeds.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.embeds_deprecated {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.mentions {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.text);
        }
        for value in &self.mentions_positions {
            my_size += ::protobuf::rt::uint32_size(5, *value);
        };
        for value in &self.embeds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.parent {
            match v {
                &cast_add_body::Parent::ParentCastId(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &cast_add_body::Parent::ParentUrl(ref v) => {
                    my_size += ::protobuf::rt::string_size(7, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.embeds_deprecated {
            os.write_string(1, &v)?;
        };
        for v in &self.mentions {
            os.write_uint64(2, *v)?;
        };
        if !self.text.is_empty() {
            os.write_string(4, &self.text)?;
        }
        for v in &self.mentions_positions {
            os.write_uint32(5, *v)?;
        };
        for v in &self.embeds {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.parent {
            match v {
                &cast_add_body::Parent::ParentCastId(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &cast_add_body::Parent::ParentUrl(ref v) => {
                    os.write_string(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CastAddBody {
        CastAddBody::new()
    }

    fn clear(&mut self) {
        self.embeds_deprecated.clear();
        self.mentions.clear();
        self.parent = ::std::option::Option::None;
        self.parent = ::std::option::Option::None;
        self.text.clear();
        self.mentions_positions.clear();
        self.embeds.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CastAddBody {
        static instance: CastAddBody = CastAddBody {
            embeds_deprecated: ::std::vec::Vec::new(),
            mentions: ::std::vec::Vec::new(),
            text: ::std::string::String::new(),
            mentions_positions: ::std::vec::Vec::new(),
            embeds: ::std::vec::Vec::new(),
            parent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CastAddBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CastAddBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CastAddBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CastAddBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CastAddBody`
pub mod cast_add_body {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CastAddBody.parent)
    pub enum Parent {
        // @@protoc_insertion_point(oneof_field:CastAddBody.parent_cast_id)
        ParentCastId(super::CastId),
        // @@protoc_insertion_point(oneof_field:CastAddBody.parent_url)
        ParentUrl(::std::string::String),
    }

    impl ::protobuf::Oneof for Parent {
    }

    impl ::protobuf::OneofFull for Parent {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::CastAddBody as ::protobuf::MessageFull>::descriptor().oneof_by_name("parent").unwrap()).clone()
        }
    }

    impl Parent {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Parent>("parent")
        }
    }
}

// @@protoc_insertion_point(message:CastRemoveBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CastRemoveBody {
    // message fields
    // @@protoc_insertion_point(field:CastRemoveBody.target_hash)
    pub target_hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:CastRemoveBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CastRemoveBody {
    fn default() -> &'a CastRemoveBody {
        <CastRemoveBody as ::protobuf::Message>::default_instance()
    }
}

impl CastRemoveBody {
    pub fn new() -> CastRemoveBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_hash",
            |m: &CastRemoveBody| { &m.target_hash },
            |m: &mut CastRemoveBody| { &mut m.target_hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CastRemoveBody>(
            "CastRemoveBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CastRemoveBody {
    const NAME: &'static str = "CastRemoveBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.target_hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.target_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.target_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.target_hash.is_empty() {
            os.write_bytes(1, &self.target_hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CastRemoveBody {
        CastRemoveBody::new()
    }

    fn clear(&mut self) {
        self.target_hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CastRemoveBody {
        static instance: CastRemoveBody = CastRemoveBody {
            target_hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CastRemoveBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CastRemoveBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CastRemoveBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CastRemoveBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CastId)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CastId {
    // message fields
    // @@protoc_insertion_point(field:CastId.fid)
    pub fid: u64,
    // @@protoc_insertion_point(field:CastId.hash)
    pub hash: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:CastId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CastId {
    fn default() -> &'a CastId {
        <CastId as ::protobuf::Message>::default_instance()
    }
}

impl CastId {
    pub fn new() -> CastId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fid",
            |m: &CastId| { &m.fid },
            |m: &mut CastId| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &CastId| { &m.hash },
            |m: &mut CastId| { &mut m.hash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CastId>(
            "CastId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CastId {
    const NAME: &'static str = "CastId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fid = is.read_uint64()?;
                },
                18 => {
                    self.hash = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.fid);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fid != 0 {
            os.write_uint64(1, self.fid)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(2, &self.hash)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CastId {
        CastId::new()
    }

    fn clear(&mut self) {
        self.fid = 0;
        self.hash.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CastId {
        static instance: CastId = CastId {
            fid: 0,
            hash: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CastId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CastId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CastId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CastId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ReactionBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ReactionBody {
    // message fields
    // @@protoc_insertion_point(field:ReactionBody.type)
    pub type_: ::protobuf::EnumOrUnknown<ReactionType>,
    // message oneof groups
    pub target: ::std::option::Option<reaction_body::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:ReactionBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReactionBody {
    fn default() -> &'a ReactionBody {
        <ReactionBody as ::protobuf::Message>::default_instance()
    }
}

impl ReactionBody {
    pub fn new() -> ReactionBody {
        ::std::default::Default::default()
    }

    // .CastId target_cast_id = 2;

    pub fn target_cast_id(&self) -> &CastId {
        match self.target {
            ::std::option::Option::Some(reaction_body::Target::TargetCastId(ref v)) => v,
            _ => <CastId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_target_cast_id(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_cast_id(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(reaction_body::Target::TargetCastId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_cast_id(&mut self, v: CastId) {
        self.target = ::std::option::Option::Some(reaction_body::Target::TargetCastId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_cast_id(&mut self) -> &mut CastId {
        if let ::std::option::Option::Some(reaction_body::Target::TargetCastId(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(reaction_body::Target::TargetCastId(CastId::new()));
        }
        match self.target {
            ::std::option::Option::Some(reaction_body::Target::TargetCastId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_cast_id(&mut self) -> CastId {
        if self.has_target_cast_id() {
            match self.target.take() {
                ::std::option::Option::Some(reaction_body::Target::TargetCastId(v)) => v,
                _ => panic!(),
            }
        } else {
            CastId::new()
        }
    }

    // string target_url = 3;

    pub fn target_url(&self) -> &str {
        match self.target {
            ::std::option::Option::Some(reaction_body::Target::TargetUrl(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_target_url(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_url(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(reaction_body::Target::TargetUrl(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_url(&mut self, v: ::std::string::String) {
        self.target = ::std::option::Option::Some(reaction_body::Target::TargetUrl(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_url(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(reaction_body::Target::TargetUrl(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(reaction_body::Target::TargetUrl(::std::string::String::new()));
        }
        match self.target {
            ::std::option::Option::Some(reaction_body::Target::TargetUrl(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_url(&mut self) -> ::std::string::String {
        if self.has_target_url() {
            match self.target.take() {
                ::std::option::Option::Some(reaction_body::Target::TargetUrl(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ReactionBody| { &m.type_ },
            |m: &mut ReactionBody| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CastId>(
            "target_cast_id",
            ReactionBody::has_target_cast_id,
            ReactionBody::target_cast_id,
            ReactionBody::mut_target_cast_id,
            ReactionBody::set_target_cast_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "target_url",
            ReactionBody::has_target_url,
            ReactionBody::target_url,
            ReactionBody::set_target_url,
        ));
        oneofs.push(reaction_body::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReactionBody>(
            "ReactionBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReactionBody {
    const NAME: &'static str = "ReactionBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.target = ::std::option::Option::Some(reaction_body::Target::TargetCastId(is.read_message()?));
                },
                26 => {
                    self.target = ::std::option::Option::Some(reaction_body::Target::TargetUrl(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(ReactionType::REACTION_TYPE_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &reaction_body::Target::TargetCastId(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &reaction_body::Target::TargetUrl(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(ReactionType::REACTION_TYPE_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &reaction_body::Target::TargetCastId(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &reaction_body::Target::TargetUrl(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReactionBody {
        ReactionBody::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(ReactionType::REACTION_TYPE_NONE);
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReactionBody {
        static instance: ReactionBody = ReactionBody {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReactionBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReactionBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReactionBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReactionBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ReactionBody`
pub mod reaction_body {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:ReactionBody.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:ReactionBody.target_cast_id)
        TargetCastId(super::CastId),
        // @@protoc_insertion_point(oneof_field:ReactionBody.target_url)
        TargetUrl(::std::string::String),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::ReactionBody as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
}

// @@protoc_insertion_point(message:VerificationAddAddressBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VerificationAddAddressBody {
    // message fields
    // @@protoc_insertion_point(field:VerificationAddAddressBody.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:VerificationAddAddressBody.claim_signature)
    pub claim_signature: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:VerificationAddAddressBody.block_hash)
    pub block_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:VerificationAddAddressBody.verification_type)
    pub verification_type: u32,
    // @@protoc_insertion_point(field:VerificationAddAddressBody.chain_id)
    pub chain_id: u32,
    // @@protoc_insertion_point(field:VerificationAddAddressBody.protocol)
    pub protocol: ::protobuf::EnumOrUnknown<Protocol>,
    // special fields
    // @@protoc_insertion_point(special_field:VerificationAddAddressBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VerificationAddAddressBody {
    fn default() -> &'a VerificationAddAddressBody {
        <VerificationAddAddressBody as ::protobuf::Message>::default_instance()
    }
}

impl VerificationAddAddressBody {
    pub fn new() -> VerificationAddAddressBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &VerificationAddAddressBody| { &m.address },
            |m: &mut VerificationAddAddressBody| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "claim_signature",
            |m: &VerificationAddAddressBody| { &m.claim_signature },
            |m: &mut VerificationAddAddressBody| { &mut m.claim_signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_hash",
            |m: &VerificationAddAddressBody| { &m.block_hash },
            |m: &mut VerificationAddAddressBody| { &mut m.block_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "verification_type",
            |m: &VerificationAddAddressBody| { &m.verification_type },
            |m: &mut VerificationAddAddressBody| { &mut m.verification_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "chain_id",
            |m: &VerificationAddAddressBody| { &m.chain_id },
            |m: &mut VerificationAddAddressBody| { &mut m.chain_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol",
            |m: &VerificationAddAddressBody| { &m.protocol },
            |m: &mut VerificationAddAddressBody| { &mut m.protocol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VerificationAddAddressBody>(
            "VerificationAddAddressBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VerificationAddAddressBody {
    const NAME: &'static str = "VerificationAddAddressBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    self.claim_signature = is.read_bytes()?;
                },
                26 => {
                    self.block_hash = is.read_bytes()?;
                },
                32 => {
                    self.verification_type = is.read_uint32()?;
                },
                40 => {
                    self.chain_id = is.read_uint32()?;
                },
                56 => {
                    self.protocol = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.claim_signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.claim_signature);
        }
        if !self.block_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.block_hash);
        }
        if self.verification_type != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.verification_type);
        }
        if self.chain_id != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.chain_id);
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(Protocol::PROTOCOL_ETHEREUM) {
            my_size += ::protobuf::rt::int32_size(7, self.protocol.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.claim_signature.is_empty() {
            os.write_bytes(2, &self.claim_signature)?;
        }
        if !self.block_hash.is_empty() {
            os.write_bytes(3, &self.block_hash)?;
        }
        if self.verification_type != 0 {
            os.write_uint32(4, self.verification_type)?;
        }
        if self.chain_id != 0 {
            os.write_uint32(5, self.chain_id)?;
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(Protocol::PROTOCOL_ETHEREUM) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.protocol))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VerificationAddAddressBody {
        VerificationAddAddressBody::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.claim_signature.clear();
        self.block_hash.clear();
        self.verification_type = 0;
        self.chain_id = 0;
        self.protocol = ::protobuf::EnumOrUnknown::new(Protocol::PROTOCOL_ETHEREUM);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VerificationAddAddressBody {
        static instance: VerificationAddAddressBody = VerificationAddAddressBody {
            address: ::std::vec::Vec::new(),
            claim_signature: ::std::vec::Vec::new(),
            block_hash: ::std::vec::Vec::new(),
            verification_type: 0,
            chain_id: 0,
            protocol: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VerificationAddAddressBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VerificationAddAddressBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VerificationAddAddressBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerificationAddAddressBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VerificationRemoveBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VerificationRemoveBody {
    // message fields
    // @@protoc_insertion_point(field:VerificationRemoveBody.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:VerificationRemoveBody.protocol)
    pub protocol: ::protobuf::EnumOrUnknown<Protocol>,
    // special fields
    // @@protoc_insertion_point(special_field:VerificationRemoveBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VerificationRemoveBody {
    fn default() -> &'a VerificationRemoveBody {
        <VerificationRemoveBody as ::protobuf::Message>::default_instance()
    }
}

impl VerificationRemoveBody {
    pub fn new() -> VerificationRemoveBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &VerificationRemoveBody| { &m.address },
            |m: &mut VerificationRemoveBody| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol",
            |m: &VerificationRemoveBody| { &m.protocol },
            |m: &mut VerificationRemoveBody| { &mut m.protocol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VerificationRemoveBody>(
            "VerificationRemoveBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VerificationRemoveBody {
    const NAME: &'static str = "VerificationRemoveBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                16 => {
                    self.protocol = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(Protocol::PROTOCOL_ETHEREUM) {
            my_size += ::protobuf::rt::int32_size(2, self.protocol.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.protocol != ::protobuf::EnumOrUnknown::new(Protocol::PROTOCOL_ETHEREUM) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.protocol))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VerificationRemoveBody {
        VerificationRemoveBody::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.protocol = ::protobuf::EnumOrUnknown::new(Protocol::PROTOCOL_ETHEREUM);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VerificationRemoveBody {
        static instance: VerificationRemoveBody = VerificationRemoveBody {
            address: ::std::vec::Vec::new(),
            protocol: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VerificationRemoveBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VerificationRemoveBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VerificationRemoveBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerificationRemoveBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LinkBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LinkBody {
    // message fields
    // @@protoc_insertion_point(field:LinkBody.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:LinkBody.displayTimestamp)
    pub displayTimestamp: ::std::option::Option<u32>,
    // message oneof groups
    pub target: ::std::option::Option<link_body::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:LinkBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LinkBody {
    fn default() -> &'a LinkBody {
        <LinkBody as ::protobuf::Message>::default_instance()
    }
}

impl LinkBody {
    pub fn new() -> LinkBody {
        ::std::default::Default::default()
    }

    // uint64 target_fid = 3;

    pub fn target_fid(&self) -> u64 {
        match self.target {
            ::std::option::Option::Some(link_body::Target::TargetFid(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_target_fid(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target_fid(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(link_body::Target::TargetFid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_fid(&mut self, v: u64) {
        self.target = ::std::option::Option::Some(link_body::Target::TargetFid(v))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &LinkBody| { &m.type_ },
            |m: &mut LinkBody| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayTimestamp",
            |m: &LinkBody| { &m.displayTimestamp },
            |m: &mut LinkBody| { &mut m.displayTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "target_fid",
            LinkBody::has_target_fid,
            LinkBody::target_fid,
            LinkBody::set_target_fid,
        ));
        oneofs.push(link_body::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LinkBody>(
            "LinkBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LinkBody {
    const NAME: &'static str = "LinkBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                16 => {
                    self.displayTimestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.target = ::std::option::Option::Some(link_body::Target::TargetFid(is.read_uint64()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        if let Some(v) = self.displayTimestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &link_body::Target::TargetFid(v) => {
                    my_size += ::protobuf::rt::uint64_size(3, v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        if let Some(v) = self.displayTimestamp {
            os.write_uint32(2, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &link_body::Target::TargetFid(v) => {
                    os.write_uint64(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LinkBody {
        LinkBody::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.displayTimestamp = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LinkBody {
        static instance: LinkBody = LinkBody {
            type_: ::std::string::String::new(),
            displayTimestamp: ::std::option::Option::None,
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LinkBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LinkBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LinkBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinkBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LinkBody`
pub mod link_body {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:LinkBody.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:LinkBody.target_fid)
        TargetFid(u64),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LinkBody as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
}

// @@protoc_insertion_point(message:FrameActionBody)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FrameActionBody {
    // message fields
    // @@protoc_insertion_point(field:FrameActionBody.url)
    pub url: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:FrameActionBody.button_index)
    pub button_index: u32,
    // @@protoc_insertion_point(field:FrameActionBody.cast_id)
    pub cast_id: ::protobuf::MessageField<CastId>,
    // @@protoc_insertion_point(field:FrameActionBody.input_text)
    pub input_text: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:FrameActionBody.state)
    pub state: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:FrameActionBody.transaction_id)
    pub transaction_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:FrameActionBody.address)
    pub address: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:FrameActionBody.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FrameActionBody {
    fn default() -> &'a FrameActionBody {
        <FrameActionBody as ::protobuf::Message>::default_instance()
    }
}

impl FrameActionBody {
    pub fn new() -> FrameActionBody {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &FrameActionBody| { &m.url },
            |m: &mut FrameActionBody| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "button_index",
            |m: &FrameActionBody| { &m.button_index },
            |m: &mut FrameActionBody| { &mut m.button_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CastId>(
            "cast_id",
            |m: &FrameActionBody| { &m.cast_id },
            |m: &mut FrameActionBody| { &mut m.cast_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "input_text",
            |m: &FrameActionBody| { &m.input_text },
            |m: &mut FrameActionBody| { &mut m.input_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &FrameActionBody| { &m.state },
            |m: &mut FrameActionBody| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transaction_id",
            |m: &FrameActionBody| { &m.transaction_id },
            |m: &mut FrameActionBody| { &mut m.transaction_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &FrameActionBody| { &m.address },
            |m: &mut FrameActionBody| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FrameActionBody>(
            "FrameActionBody",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FrameActionBody {
    const NAME: &'static str = "FrameActionBody";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_bytes()?;
                },
                16 => {
                    self.button_index = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cast_id)?;
                },
                34 => {
                    self.input_text = is.read_bytes()?;
                },
                42 => {
                    self.state = is.read_bytes()?;
                },
                50 => {
                    self.transaction_id = is.read_bytes()?;
                },
                58 => {
                    self.address = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.url);
        }
        if self.button_index != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.button_index);
        }
        if let Some(v) = self.cast_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.input_text.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.input_text);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.state);
        }
        if !self.transaction_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.transaction_id);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_bytes(1, &self.url)?;
        }
        if self.button_index != 0 {
            os.write_uint32(2, self.button_index)?;
        }
        if let Some(v) = self.cast_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.input_text.is_empty() {
            os.write_bytes(4, &self.input_text)?;
        }
        if !self.state.is_empty() {
            os.write_bytes(5, &self.state)?;
        }
        if !self.transaction_id.is_empty() {
            os.write_bytes(6, &self.transaction_id)?;
        }
        if !self.address.is_empty() {
            os.write_bytes(7, &self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FrameActionBody {
        FrameActionBody::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.button_index = 0;
        self.cast_id.clear();
        self.input_text.clear();
        self.state.clear();
        self.transaction_id.clear();
        self.address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FrameActionBody {
        static instance: FrameActionBody = FrameActionBody {
            url: ::std::vec::Vec::new(),
            button_index: 0,
            cast_id: ::protobuf::MessageField::none(),
            input_text: ::std::vec::Vec::new(),
            state: ::std::vec::Vec::new(),
            transaction_id: ::std::vec::Vec::new(),
            address: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FrameActionBody {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FrameActionBody").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FrameActionBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FrameActionBody {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:HashScheme)
pub enum HashScheme {
    // @@protoc_insertion_point(enum_value:HashScheme.HASH_SCHEME_NONE)
    HASH_SCHEME_NONE = 0,
    // @@protoc_insertion_point(enum_value:HashScheme.HASH_SCHEME_BLAKE3)
    HASH_SCHEME_BLAKE3 = 1,
}

impl ::protobuf::Enum for HashScheme {
    const NAME: &'static str = "HashScheme";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HashScheme> {
        match value {
            0 => ::std::option::Option::Some(HashScheme::HASH_SCHEME_NONE),
            1 => ::std::option::Option::Some(HashScheme::HASH_SCHEME_BLAKE3),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<HashScheme> {
        match str {
            "HASH_SCHEME_NONE" => ::std::option::Option::Some(HashScheme::HASH_SCHEME_NONE),
            "HASH_SCHEME_BLAKE3" => ::std::option::Option::Some(HashScheme::HASH_SCHEME_BLAKE3),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [HashScheme] = &[
        HashScheme::HASH_SCHEME_NONE,
        HashScheme::HASH_SCHEME_BLAKE3,
    ];
}

impl ::protobuf::EnumFull for HashScheme {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("HashScheme").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for HashScheme {
    fn default() -> Self {
        HashScheme::HASH_SCHEME_NONE
    }
}

impl HashScheme {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<HashScheme>("HashScheme")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SignatureScheme)
pub enum SignatureScheme {
    // @@protoc_insertion_point(enum_value:SignatureScheme.SIGNATURE_SCHEME_NONE)
    SIGNATURE_SCHEME_NONE = 0,
    // @@protoc_insertion_point(enum_value:SignatureScheme.SIGNATURE_SCHEME_ED25519)
    SIGNATURE_SCHEME_ED25519 = 1,
    // @@protoc_insertion_point(enum_value:SignatureScheme.SIGNATURE_SCHEME_EIP712)
    SIGNATURE_SCHEME_EIP712 = 2,
}

impl ::protobuf::Enum for SignatureScheme {
    const NAME: &'static str = "SignatureScheme";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SignatureScheme> {
        match value {
            0 => ::std::option::Option::Some(SignatureScheme::SIGNATURE_SCHEME_NONE),
            1 => ::std::option::Option::Some(SignatureScheme::SIGNATURE_SCHEME_ED25519),
            2 => ::std::option::Option::Some(SignatureScheme::SIGNATURE_SCHEME_EIP712),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SignatureScheme> {
        match str {
            "SIGNATURE_SCHEME_NONE" => ::std::option::Option::Some(SignatureScheme::SIGNATURE_SCHEME_NONE),
            "SIGNATURE_SCHEME_ED25519" => ::std::option::Option::Some(SignatureScheme::SIGNATURE_SCHEME_ED25519),
            "SIGNATURE_SCHEME_EIP712" => ::std::option::Option::Some(SignatureScheme::SIGNATURE_SCHEME_EIP712),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SignatureScheme] = &[
        SignatureScheme::SIGNATURE_SCHEME_NONE,
        SignatureScheme::SIGNATURE_SCHEME_ED25519,
        SignatureScheme::SIGNATURE_SCHEME_EIP712,
    ];
}

impl ::protobuf::EnumFull for SignatureScheme {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SignatureScheme").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SignatureScheme {
    fn default() -> Self {
        SignatureScheme::SIGNATURE_SCHEME_NONE
    }
}

impl SignatureScheme {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SignatureScheme>("SignatureScheme")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MessageType)
pub enum MessageType {
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_NONE)
    MESSAGE_TYPE_NONE = 0,
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_CAST_ADD)
    MESSAGE_TYPE_CAST_ADD = 1,
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_CAST_REMOVE)
    MESSAGE_TYPE_CAST_REMOVE = 2,
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_REACTION_ADD)
    MESSAGE_TYPE_REACTION_ADD = 3,
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_REACTION_REMOVE)
    MESSAGE_TYPE_REACTION_REMOVE = 4,
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_LINK_ADD)
    MESSAGE_TYPE_LINK_ADD = 5,
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_LINK_REMOVE)
    MESSAGE_TYPE_LINK_REMOVE = 6,
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS)
    MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS = 7,
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_VERIFICATION_REMOVE)
    MESSAGE_TYPE_VERIFICATION_REMOVE = 8,
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_USER_DATA_ADD)
    MESSAGE_TYPE_USER_DATA_ADD = 11,
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_USERNAME_PROOF)
    MESSAGE_TYPE_USERNAME_PROOF = 12,
    // @@protoc_insertion_point(enum_value:MessageType.MESSAGE_TYPE_FRAME_ACTION)
    MESSAGE_TYPE_FRAME_ACTION = 13,
}

impl ::protobuf::Enum for MessageType {
    const NAME: &'static str = "MessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MessageType> {
        match value {
            0 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_NONE),
            1 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_CAST_ADD),
            2 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_CAST_REMOVE),
            3 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_REACTION_ADD),
            4 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_REACTION_REMOVE),
            5 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_LINK_ADD),
            6 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_LINK_REMOVE),
            7 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS),
            8 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_VERIFICATION_REMOVE),
            11 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_USER_DATA_ADD),
            12 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_USERNAME_PROOF),
            13 => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_FRAME_ACTION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MessageType> {
        match str {
            "MESSAGE_TYPE_NONE" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_NONE),
            "MESSAGE_TYPE_CAST_ADD" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_CAST_ADD),
            "MESSAGE_TYPE_CAST_REMOVE" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_CAST_REMOVE),
            "MESSAGE_TYPE_REACTION_ADD" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_REACTION_ADD),
            "MESSAGE_TYPE_REACTION_REMOVE" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_REACTION_REMOVE),
            "MESSAGE_TYPE_LINK_ADD" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_LINK_ADD),
            "MESSAGE_TYPE_LINK_REMOVE" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_LINK_REMOVE),
            "MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS),
            "MESSAGE_TYPE_VERIFICATION_REMOVE" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_VERIFICATION_REMOVE),
            "MESSAGE_TYPE_USER_DATA_ADD" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_USER_DATA_ADD),
            "MESSAGE_TYPE_USERNAME_PROOF" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_USERNAME_PROOF),
            "MESSAGE_TYPE_FRAME_ACTION" => ::std::option::Option::Some(MessageType::MESSAGE_TYPE_FRAME_ACTION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MessageType] = &[
        MessageType::MESSAGE_TYPE_NONE,
        MessageType::MESSAGE_TYPE_CAST_ADD,
        MessageType::MESSAGE_TYPE_CAST_REMOVE,
        MessageType::MESSAGE_TYPE_REACTION_ADD,
        MessageType::MESSAGE_TYPE_REACTION_REMOVE,
        MessageType::MESSAGE_TYPE_LINK_ADD,
        MessageType::MESSAGE_TYPE_LINK_REMOVE,
        MessageType::MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS,
        MessageType::MESSAGE_TYPE_VERIFICATION_REMOVE,
        MessageType::MESSAGE_TYPE_USER_DATA_ADD,
        MessageType::MESSAGE_TYPE_USERNAME_PROOF,
        MessageType::MESSAGE_TYPE_FRAME_ACTION,
    ];
}

impl ::protobuf::EnumFull for MessageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MessageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            MessageType::MESSAGE_TYPE_NONE => 0,
            MessageType::MESSAGE_TYPE_CAST_ADD => 1,
            MessageType::MESSAGE_TYPE_CAST_REMOVE => 2,
            MessageType::MESSAGE_TYPE_REACTION_ADD => 3,
            MessageType::MESSAGE_TYPE_REACTION_REMOVE => 4,
            MessageType::MESSAGE_TYPE_LINK_ADD => 5,
            MessageType::MESSAGE_TYPE_LINK_REMOVE => 6,
            MessageType::MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS => 7,
            MessageType::MESSAGE_TYPE_VERIFICATION_REMOVE => 8,
            MessageType::MESSAGE_TYPE_USER_DATA_ADD => 9,
            MessageType::MESSAGE_TYPE_USERNAME_PROOF => 10,
            MessageType::MESSAGE_TYPE_FRAME_ACTION => 11,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MessageType {
    fn default() -> Self {
        MessageType::MESSAGE_TYPE_NONE
    }
}

impl MessageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MessageType>("MessageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:FarcasterNetwork)
pub enum FarcasterNetwork {
    // @@protoc_insertion_point(enum_value:FarcasterNetwork.FARCASTER_NETWORK_NONE)
    FARCASTER_NETWORK_NONE = 0,
    // @@protoc_insertion_point(enum_value:FarcasterNetwork.FARCASTER_NETWORK_MAINNET)
    FARCASTER_NETWORK_MAINNET = 1,
    // @@protoc_insertion_point(enum_value:FarcasterNetwork.FARCASTER_NETWORK_TESTNET)
    FARCASTER_NETWORK_TESTNET = 2,
    // @@protoc_insertion_point(enum_value:FarcasterNetwork.FARCASTER_NETWORK_DEVNET)
    FARCASTER_NETWORK_DEVNET = 3,
}

impl ::protobuf::Enum for FarcasterNetwork {
    const NAME: &'static str = "FarcasterNetwork";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FarcasterNetwork> {
        match value {
            0 => ::std::option::Option::Some(FarcasterNetwork::FARCASTER_NETWORK_NONE),
            1 => ::std::option::Option::Some(FarcasterNetwork::FARCASTER_NETWORK_MAINNET),
            2 => ::std::option::Option::Some(FarcasterNetwork::FARCASTER_NETWORK_TESTNET),
            3 => ::std::option::Option::Some(FarcasterNetwork::FARCASTER_NETWORK_DEVNET),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FarcasterNetwork> {
        match str {
            "FARCASTER_NETWORK_NONE" => ::std::option::Option::Some(FarcasterNetwork::FARCASTER_NETWORK_NONE),
            "FARCASTER_NETWORK_MAINNET" => ::std::option::Option::Some(FarcasterNetwork::FARCASTER_NETWORK_MAINNET),
            "FARCASTER_NETWORK_TESTNET" => ::std::option::Option::Some(FarcasterNetwork::FARCASTER_NETWORK_TESTNET),
            "FARCASTER_NETWORK_DEVNET" => ::std::option::Option::Some(FarcasterNetwork::FARCASTER_NETWORK_DEVNET),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FarcasterNetwork] = &[
        FarcasterNetwork::FARCASTER_NETWORK_NONE,
        FarcasterNetwork::FARCASTER_NETWORK_MAINNET,
        FarcasterNetwork::FARCASTER_NETWORK_TESTNET,
        FarcasterNetwork::FARCASTER_NETWORK_DEVNET,
    ];
}

impl ::protobuf::EnumFull for FarcasterNetwork {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FarcasterNetwork").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FarcasterNetwork {
    fn default() -> Self {
        FarcasterNetwork::FARCASTER_NETWORK_NONE
    }
}

impl FarcasterNetwork {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FarcasterNetwork>("FarcasterNetwork")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:UserDataType)
pub enum UserDataType {
    // @@protoc_insertion_point(enum_value:UserDataType.USER_DATA_TYPE_NONE)
    USER_DATA_TYPE_NONE = 0,
    // @@protoc_insertion_point(enum_value:UserDataType.USER_DATA_TYPE_PFP)
    USER_DATA_TYPE_PFP = 1,
    // @@protoc_insertion_point(enum_value:UserDataType.USER_DATA_TYPE_DISPLAY)
    USER_DATA_TYPE_DISPLAY = 2,
    // @@protoc_insertion_point(enum_value:UserDataType.USER_DATA_TYPE_BIO)
    USER_DATA_TYPE_BIO = 3,
    // @@protoc_insertion_point(enum_value:UserDataType.USER_DATA_TYPE_URL)
    USER_DATA_TYPE_URL = 5,
    // @@protoc_insertion_point(enum_value:UserDataType.USER_DATA_TYPE_USERNAME)
    USER_DATA_TYPE_USERNAME = 6,
}

impl ::protobuf::Enum for UserDataType {
    const NAME: &'static str = "UserDataType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UserDataType> {
        match value {
            0 => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_NONE),
            1 => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_PFP),
            2 => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_DISPLAY),
            3 => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_BIO),
            5 => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_URL),
            6 => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_USERNAME),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<UserDataType> {
        match str {
            "USER_DATA_TYPE_NONE" => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_NONE),
            "USER_DATA_TYPE_PFP" => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_PFP),
            "USER_DATA_TYPE_DISPLAY" => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_DISPLAY),
            "USER_DATA_TYPE_BIO" => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_BIO),
            "USER_DATA_TYPE_URL" => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_URL),
            "USER_DATA_TYPE_USERNAME" => ::std::option::Option::Some(UserDataType::USER_DATA_TYPE_USERNAME),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [UserDataType] = &[
        UserDataType::USER_DATA_TYPE_NONE,
        UserDataType::USER_DATA_TYPE_PFP,
        UserDataType::USER_DATA_TYPE_DISPLAY,
        UserDataType::USER_DATA_TYPE_BIO,
        UserDataType::USER_DATA_TYPE_URL,
        UserDataType::USER_DATA_TYPE_USERNAME,
    ];
}

impl ::protobuf::EnumFull for UserDataType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("UserDataType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            UserDataType::USER_DATA_TYPE_NONE => 0,
            UserDataType::USER_DATA_TYPE_PFP => 1,
            UserDataType::USER_DATA_TYPE_DISPLAY => 2,
            UserDataType::USER_DATA_TYPE_BIO => 3,
            UserDataType::USER_DATA_TYPE_URL => 4,
            UserDataType::USER_DATA_TYPE_USERNAME => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for UserDataType {
    fn default() -> Self {
        UserDataType::USER_DATA_TYPE_NONE
    }
}

impl UserDataType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<UserDataType>("UserDataType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ReactionType)
pub enum ReactionType {
    // @@protoc_insertion_point(enum_value:ReactionType.REACTION_TYPE_NONE)
    REACTION_TYPE_NONE = 0,
    // @@protoc_insertion_point(enum_value:ReactionType.REACTION_TYPE_LIKE)
    REACTION_TYPE_LIKE = 1,
    // @@protoc_insertion_point(enum_value:ReactionType.REACTION_TYPE_RECAST)
    REACTION_TYPE_RECAST = 2,
}

impl ::protobuf::Enum for ReactionType {
    const NAME: &'static str = "ReactionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReactionType> {
        match value {
            0 => ::std::option::Option::Some(ReactionType::REACTION_TYPE_NONE),
            1 => ::std::option::Option::Some(ReactionType::REACTION_TYPE_LIKE),
            2 => ::std::option::Option::Some(ReactionType::REACTION_TYPE_RECAST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ReactionType> {
        match str {
            "REACTION_TYPE_NONE" => ::std::option::Option::Some(ReactionType::REACTION_TYPE_NONE),
            "REACTION_TYPE_LIKE" => ::std::option::Option::Some(ReactionType::REACTION_TYPE_LIKE),
            "REACTION_TYPE_RECAST" => ::std::option::Option::Some(ReactionType::REACTION_TYPE_RECAST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ReactionType] = &[
        ReactionType::REACTION_TYPE_NONE,
        ReactionType::REACTION_TYPE_LIKE,
        ReactionType::REACTION_TYPE_RECAST,
    ];
}

impl ::protobuf::EnumFull for ReactionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ReactionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ReactionType {
    fn default() -> Self {
        ReactionType::REACTION_TYPE_NONE
    }
}

impl ReactionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ReactionType>("ReactionType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Protocol)
pub enum Protocol {
    // @@protoc_insertion_point(enum_value:Protocol.PROTOCOL_ETHEREUM)
    PROTOCOL_ETHEREUM = 0,
    // @@protoc_insertion_point(enum_value:Protocol.PROTOCOL_SOLANA)
    PROTOCOL_SOLANA = 1,
}

impl ::protobuf::Enum for Protocol {
    const NAME: &'static str = "Protocol";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Protocol> {
        match value {
            0 => ::std::option::Option::Some(Protocol::PROTOCOL_ETHEREUM),
            1 => ::std::option::Option::Some(Protocol::PROTOCOL_SOLANA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Protocol> {
        match str {
            "PROTOCOL_ETHEREUM" => ::std::option::Option::Some(Protocol::PROTOCOL_ETHEREUM),
            "PROTOCOL_SOLANA" => ::std::option::Option::Some(Protocol::PROTOCOL_SOLANA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Protocol] = &[
        Protocol::PROTOCOL_ETHEREUM,
        Protocol::PROTOCOL_SOLANA,
    ];
}

impl ::protobuf::EnumFull for Protocol {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Protocol").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for Protocol {
    fn default() -> Self {
        Protocol::PROTOCOL_ETHEREUM
    }
}

impl Protocol {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Protocol>("Protocol")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rmessage.proto\x1a\x14username_proof.proto\"\x93\x02\n\x07Message\x12\
    \x20\n\x04data\x18\x01\x20\x01(\x0b2\x0c.MessageDataR\x04data\x12\x12\n\
    \x04hash\x18\x02\x20\x01(\x0cR\x04hash\x12,\n\x0bhash_scheme\x18\x03\x20\
    \x01(\x0e2\x0b.HashSchemeR\nhashScheme\x12\x1c\n\tsignature\x18\x04\x20\
    \x01(\x0cR\tsignature\x12;\n\x10signature_scheme\x18\x05\x20\x01(\x0e2\
    \x10.SignatureSchemeR\x0fsignatureScheme\x12\x16\n\x06signer\x18\x06\x20\
    \x01(\x0cR\x06signer\x12\"\n\ndata_bytes\x18\x07\x20\x01(\x0cH\0R\tdataB\
    ytes\x88\x01\x01B\r\n\x0b_data_bytes\"\xd5\x05\n\x0bMessageData\x12\x20\
    \n\x04type\x18\x01\x20\x01(\x0e2\x0c.MessageTypeR\x04type\x12\x10\n\x03f\
    id\x18\x02\x20\x01(\x04R\x03fid\x12\x1c\n\ttimestamp\x18\x03\x20\x01(\rR\
    \ttimestamp\x12+\n\x07network\x18\x04\x20\x01(\x0e2\x11.FarcasterNetwork\
    R\x07network\x122\n\rcast_add_body\x18\x05\x20\x01(\x0b2\x0c.CastAddBody\
    H\0R\x0bcastAddBody\x12;\n\x10cast_remove_body\x18\x06\x20\x01(\x0b2\x0f\
    .CastRemoveBodyH\0R\x0ecastRemoveBody\x124\n\rreaction_body\x18\x07\x20\
    \x01(\x0b2\r.ReactionBodyH\0R\x0creactionBody\x12`\n\x1dverification_add\
    _address_body\x18\t\x20\x01(\x0b2\x1b.VerificationAddAddressBodyH\0R\x1a\
    verificationAddAddressBody\x12S\n\x18verification_remove_body\x18\n\x20\
    \x01(\x0b2\x17.VerificationRemoveBodyH\0R\x16verificationRemoveBody\x125\
    \n\x0euser_data_body\x18\x0c\x20\x01(\x0b2\r.UserDataBodyH\0R\x0cuserDat\
    aBody\x12(\n\tlink_body\x18\x0e\x20\x01(\x0b2\t.LinkBodyH\0R\x08linkBody\
    \x12@\n\x13username_proof_body\x18\x0f\x20\x01(\x0b2\x0e.UserNameProofH\
    \0R\x11usernameProofBody\x12>\n\x11frame_action_body\x18\x10\x20\x01(\
    \x0b2\x10.FrameActionBodyH\0R\x0fframeActionBodyB\x06\n\x04body\"G\n\x0c\
    UserDataBody\x12!\n\x04type\x18\x01\x20\x01(\x0e2\r.UserDataTypeR\x04typ\
    e\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"H\n\x05Embed\x12\x12\
    \n\x03url\x18\x01\x20\x01(\tH\0R\x03url\x12\"\n\x07cast_id\x18\x02\x20\
    \x01(\x0b2\x07.CastIdH\0R\x06castIdB\x07\n\x05embed\"\x95\x02\n\x0bCastA\
    ddBody\x12+\n\x11embeds_deprecated\x18\x01\x20\x03(\tR\x10embedsDeprecat\
    ed\x12\x1a\n\x08mentions\x18\x02\x20\x03(\x04R\x08mentions\x12/\n\x0epar\
    ent_cast_id\x18\x03\x20\x01(\x0b2\x07.CastIdH\0R\x0cparentCastId\x12\x1f\
    \n\nparent_url\x18\x07\x20\x01(\tH\0R\tparentUrl\x12\x12\n\x04text\x18\
    \x04\x20\x01(\tR\x04text\x12-\n\x12mentions_positions\x18\x05\x20\x03(\r\
    R\x11mentionsPositions\x12\x1e\n\x06embeds\x18\x06\x20\x03(\x0b2\x06.Emb\
    edR\x06embedsB\x08\n\x06parent\"1\n\x0eCastRemoveBody\x12\x1f\n\x0btarge\
    t_hash\x18\x01\x20\x01(\x0cR\ntargetHash\".\n\x06CastId\x12\x10\n\x03fid\
    \x18\x01\x20\x01(\x04R\x03fid\x12\x12\n\x04hash\x18\x02\x20\x01(\x0cR\
    \x04hash\"\x8d\x01\n\x0cReactionBody\x12!\n\x04type\x18\x01\x20\x01(\x0e\
    2\r.ReactionTypeR\x04type\x12/\n\x0etarget_cast_id\x18\x02\x20\x01(\x0b2\
    \x07.CastIdH\0R\x0ctargetCastId\x12\x1f\n\ntarget_url\x18\x03\x20\x01(\t\
    H\0R\ttargetUrlB\x08\n\x06target\"\xed\x01\n\x1aVerificationAddAddressBo\
    dy\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12'\n\x0fclaim\
    _signature\x18\x02\x20\x01(\x0cR\x0eclaimSignature\x12\x1d\n\nblock_hash\
    \x18\x03\x20\x01(\x0cR\tblockHash\x12+\n\x11verification_type\x18\x04\
    \x20\x01(\rR\x10verificationType\x12\x19\n\x08chain_id\x18\x05\x20\x01(\
    \rR\x07chainId\x12%\n\x08protocol\x18\x07\x20\x01(\x0e2\t.ProtocolR\x08p\
    rotocol\"Y\n\x16VerificationRemoveBody\x12\x18\n\x07address\x18\x01\x20\
    \x01(\x0cR\x07address\x12%\n\x08protocol\x18\x02\x20\x01(\x0e2\t.Protoco\
    lR\x08protocol\"\x8f\x01\n\x08LinkBody\x12\x12\n\x04type\x18\x01\x20\x01\
    (\tR\x04type\x12/\n\x10displayTimestamp\x18\x02\x20\x01(\rH\x01R\x10disp\
    layTimestamp\x88\x01\x01\x12\x1f\n\ntarget_fid\x18\x03\x20\x01(\x04H\0R\
    \ttargetFidB\x08\n\x06targetB\x13\n\x11_displayTimestamp\"\xde\x01\n\x0f\
    FrameActionBody\x12\x10\n\x03url\x18\x01\x20\x01(\x0cR\x03url\x12!\n\x0c\
    button_index\x18\x02\x20\x01(\rR\x0bbuttonIndex\x12\x20\n\x07cast_id\x18\
    \x03\x20\x01(\x0b2\x07.CastIdR\x06castId\x12\x1d\n\ninput_text\x18\x04\
    \x20\x01(\x0cR\tinputText\x12\x14\n\x05state\x18\x05\x20\x01(\x0cR\x05st\
    ate\x12%\n\x0etransaction_id\x18\x06\x20\x01(\x0cR\rtransactionId\x12\
    \x18\n\x07address\x18\x07\x20\x01(\x0cR\x07address*:\n\nHashScheme\x12\
    \x14\n\x10HASH_SCHEME_NONE\x10\0\x12\x16\n\x12HASH_SCHEME_BLAKE3\x10\x01\
    *g\n\x0fSignatureScheme\x12\x19\n\x15SIGNATURE_SCHEME_NONE\x10\0\x12\x1c\
    \n\x18SIGNATURE_SCHEME_ED25519\x10\x01\x12\x1b\n\x17SIGNATURE_SCHEME_EIP\
    712\x10\x02*\x8c\x03\n\x0bMessageType\x12\x15\n\x11MESSAGE_TYPE_NONE\x10\
    \0\x12\x19\n\x15MESSAGE_TYPE_CAST_ADD\x10\x01\x12\x1c\n\x18MESSAGE_TYPE_\
    CAST_REMOVE\x10\x02\x12\x1d\n\x19MESSAGE_TYPE_REACTION_ADD\x10\x03\x12\
    \x20\n\x1cMESSAGE_TYPE_REACTION_REMOVE\x10\x04\x12\x19\n\x15MESSAGE_TYPE\
    _LINK_ADD\x10\x05\x12\x1c\n\x18MESSAGE_TYPE_LINK_REMOVE\x10\x06\x12-\n)M\
    ESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS\x10\x07\x12$\n\x20MESSAGE_TYPE_\
    VERIFICATION_REMOVE\x10\x08\x12\x1e\n\x1aMESSAGE_TYPE_USER_DATA_ADD\x10\
    \x0b\x12\x1f\n\x1bMESSAGE_TYPE_USERNAME_PROOF\x10\x0c\x12\x1d\n\x19MESSA\
    GE_TYPE_FRAME_ACTION\x10\r*\x8a\x01\n\x10FarcasterNetwork\x12\x1a\n\x16F\
    ARCASTER_NETWORK_NONE\x10\0\x12\x1d\n\x19FARCASTER_NETWORK_MAINNET\x10\
    \x01\x12\x1d\n\x19FARCASTER_NETWORK_TESTNET\x10\x02\x12\x1c\n\x18FARCAST\
    ER_NETWORK_DEVNET\x10\x03*\xa8\x01\n\x0cUserDataType\x12\x17\n\x13USER_D\
    ATA_TYPE_NONE\x10\0\x12\x16\n\x12USER_DATA_TYPE_PFP\x10\x01\x12\x1a\n\
    \x16USER_DATA_TYPE_DISPLAY\x10\x02\x12\x16\n\x12USER_DATA_TYPE_BIO\x10\
    \x03\x12\x16\n\x12USER_DATA_TYPE_URL\x10\x05\x12\x1b\n\x17USER_DATA_TYPE\
    _USERNAME\x10\x06*X\n\x0cReactionType\x12\x16\n\x12REACTION_TYPE_NONE\
    \x10\0\x12\x16\n\x12REACTION_TYPE_LIKE\x10\x01\x12\x18\n\x14REACTION_TYP\
    E_RECAST\x10\x02*6\n\x08Protocol\x12\x15\n\x11PROTOCOL_ETHEREUM\x10\0\
    \x12\x13\n\x0fPROTOCOL_SOLANA\x10\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::username_proof::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(12);
            messages.push(Message::generated_message_descriptor_data());
            messages.push(MessageData::generated_message_descriptor_data());
            messages.push(UserDataBody::generated_message_descriptor_data());
            messages.push(Embed::generated_message_descriptor_data());
            messages.push(CastAddBody::generated_message_descriptor_data());
            messages.push(CastRemoveBody::generated_message_descriptor_data());
            messages.push(CastId::generated_message_descriptor_data());
            messages.push(ReactionBody::generated_message_descriptor_data());
            messages.push(VerificationAddAddressBody::generated_message_descriptor_data());
            messages.push(VerificationRemoveBody::generated_message_descriptor_data());
            messages.push(LinkBody::generated_message_descriptor_data());
            messages.push(FrameActionBody::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(7);
            enums.push(HashScheme::generated_enum_descriptor_data());
            enums.push(SignatureScheme::generated_enum_descriptor_data());
            enums.push(MessageType::generated_enum_descriptor_data());
            enums.push(FarcasterNetwork::generated_enum_descriptor_data());
            enums.push(UserDataType::generated_enum_descriptor_data());
            enums.push(ReactionType::generated_enum_descriptor_data());
            enums.push(Protocol::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
